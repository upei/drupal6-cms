<?php
// $Id: imagecache_canvasactions.module,v 1.3.2.10 2009/03/15 15:13:39 dman Exp $

/**
 * @file A collection of canvas (layer) type manipulations for imagecache -
 * including "Watermark"
 *
 * Based on first draft of the code by Dimm (imagecache.module 5--1)
 * http://drupal.org/node/184816
 *
 * Rewritten and ported to Imagecache actions API (imagecache.module 5--2) by
 * dman http://coders.co.nz/
 *
 *
 * Notes about imagecache action extensions. For each action:
 *
 * 1: Impliment imagecache_HOOK_form($formdata) to define the config form.
 *
 * 1a: Impliment theme_imagecache_HOOK_form if needed - optional
 *
 * 2: Impliment imagecache_HOOK_image(&$image, $data) to DO the process
 *
 * 3: Impliment theme_imagecache_HOOK($element) to return a text description of
 * the setting
 *
 * 4: Declare the action in HOOK_imagecache_actions()
 *
 *
 * API ref for hook_image()
 *
 * @param $image array defining an image file, including  :
 *
 *   $image- >source as the filename,
 *
 *   $image->info array
 *
 *   $image->res handle on the image object
 *
 * @param $action array of settings as defined in your form.
 *
 */

// During devel, caching is pointless. Flush it
// imagecache_action_definitions(TRUE);

require_once(dirname(__FILE__) .'/utility.inc');

/**
* Implementation of hook_imagecache_actions().
*
* Declare available actions, return help text about this filter.
*
* These funcs are all in their respective include libraries - as configured below
*/
function imagecache_canvasactions_imagecache_actions() {

  $actions = array(
    'canvasactions_definecanvas' => array(
      'name' => t('Define Canvas'),
      'description' => t('Define the size of the working canvas and background color, this controls the dimensions of the output image..'),
      'file' => 'canvasactions.inc',
    ),
    'canvasactions_file2canvas' => array(
      'name' => t('Overlay: file image to canvas (watermark)'),
      'description' => t(' Choose the file image you wish to use as an overlay, and position it in a layer on top of the canvas.'),
      'file' => 'canvasactions.inc',
    ),
    'canvasactions_canvas2file' => array(
      'name' => t('Underlay: place a file image under the current image (background)'),
      'description' => t(' Choose the file image you wish to use as an background, and position the processed image on it.'),
      'file' => 'canvasactions.inc',
    ),
    'canvasactions_roundedcorners' => array(
      'name' => t('Rounded Corners: Set a radius to crop corners by.'),
      'description' => t(' This is true cropping, not overlays, so the result <em>can</em> be transparent.'),
      'file' => 'canvasactions.inc',
    ),
    'canvasactions_aspect' => array(
      'name' => t('Aspect switcher: '),
      'description' => t(' Use different effects depending on whether the image is landscape of portrait shaped. This re-uses other preset definitions, and just chooses between them based on the rule.'),
      'file' => 'canvasactions.inc',
    ),

  );

  return $actions;
}


//////////////////////
// imageapi extensions
// Maybe shift into there one day

/**
 * Place one image over another
 *
 * @param $layer may be a filename or an imageAPI object
 * @return bool success
 * @ingroup imageapi
 */
function imageapi_image_overlay(&$image, $overlay, $x, $y, $alpha, $reverse = FALSE) {
  return imageapi_toolkit_invoke('overlay', $image, array($overlay, $x, $y, $alpha, $reverse));
  
#  return call_user_func_array($image->toolkit .'_image_overlay', array(&$image, $overlay, $x, $y, $alpha, $reverse));
}

/**
 * Place one image over another
 * This modifies the passed image by reference
 * 
 * This func is nominated for inclusion in imageapi package. Until then, we do
 * it ourselves.
 * 
 * NOTE that the PHP libraries are not great at merging images SO we include a
 * library that does it pixel-by-pixel which is INCREDIBLY inefficient. If this
 * can be improved, in a way that supports all transparency, please let us know!
 *
 * A watermark is layer onto image, return the image. An underlay is image onto
 * layer, return the layer. Almost identical, but seeing as we work with
 * resource handles, the handle needs to be swapped before returning.
 *
 * @ingroup imageapi
 * @param &$image
 * @param $layer may be a filename or an imageAPI object
 * @param $alpha from 0-100.
 * @param $reverse Whether to do an underlay with the static image layer instead
 * @return  bool success
 */
function imageapi_gd_image_overlay(&$image, &$layer, $x, $y, $alpha, $reverse = FALSE) {
  if (is_string($layer) ) {
    if (! file_exists($layer)) {
      trigger_error("Image file does not exist. Attempted to overlay $layer", E_USER_ERROR);
      return FALSE;
    }
    $layer = imageapi_image_open($layer);
  }
  // else $layer better be an image handle

  $x_ins = _imagecache_keyword_filter($x, $image->info['width'], $layer->info['width']);
  $y_ins = _imagecache_keyword_filter($y, $image->info['height'], $layer->info['height']);

  // If the given alpha is 100%, we can use imagecopy - which actually works, 
  // Is more efficient, and seems to retain the overlays partial transparancy
  // Still does not work great for indexed gifs though?

  if($alpha == 100 && ($layer->info['mime_type'] != 'image/gif')) {
    imagealphablending($image->resource, TRUE);
    imagesavealpha($image->resource, TRUE);
    imagealphablending($layer->resource, TRUE);
    imagesavealpha($layer->resource, TRUE);
    imagecopy($image->resource, $layer->resource, $x_ins, $y_ins, 0, 0, $layer->info['width'], $layer->info['height']);
    imagedestroy($layer->resource);
    return TRUE;
  }
  // else imagecopymerge fails and we have to use the slow library 

  // imagecopymerge doesn't do alpha transparency right?
  //imagealphablending($image->res, false);
  //imagesavealpha($image->res, TRUE);
  //imagealphablending($layer->res, false);
  //imagesavealpha($layer->res, TRUE);
  // imagecopymerge($image->res, $layer->res, $x_ins, $y_ins, 0, 0, $layer->info['width'], $layer->info['height'], $alpha);
  // Silly thing, it's easy. Use the attached library below instead

  require_once('watermark.inc');
  $watermark = new watermark();
  $image->resource = $watermark->create_watermark($image->resource, $layer->resource, $x_ins, $y_ins, $alpha);

  if ($reverse) {
    // When doing underlay, It's the second image object that we really care about. 
    // Update that with the result
    $layer->resource = $image->resource;
  }
  else {
    imagedestroy($layer->resource);
  }
  
  return TRUE;
}

/**
 * This preliminary function copied over from 
 * http://drupal.org/project/bc_imagecache_adv_actions at 2008-10-18
 * 
 * Maybe it will work. I have no idea.
 * 
 * UNTESTED beware.
 */
function imageapi_imagemagick_image_overlay(&$frontImage, $bgImage, $x = 0, $y = 0, $adjx = 0, $adjy = 0) {
    $dst = file_create_filename( uniqid('im') . '.' . $frontImage->info['extension'] , 'files/tmp'  );
    $dst2 = file_create_filename( uniqid('im2') .'.' . $frontImage->info['extension']  , 'files/tmp'  );
    $image = imageapi_image_open($bgImage) ;

    if ( $y == 'middle' ) {
        $y = ($image->info['height'] / 2) -  $frontImage->info['height'] / 2 - $adjy ;
    }
    if ( $x == 'middle' ) {
        $x = ($image->info['width'] / 2) -  $frontImage->info['width'] / 2 - $adjx;
    }
    imageapi_image_close($frontImage, $dst);
    $image->ops[] = ' -draw "image over '.$x.','.$y.' 0,0 \''.$dst.'\'"'  ;
    imageapi_image_close($image, $dst2);
    return $dst2;
}

/**
 * Need to register the theme functions we expect to use
 */
function imagecache_canvasactions_theme() {
  return array(
    'imagecacheactions_rgb_form' => array(
      'file'      => 'utility.inc',
      'arguments' => array('form' => NULL),
    ),
    'imagecacheactions_rgb' => array(
      'file'      => 'utility.inc',
      'arguments' => array('rgb' => NULL),
    ),
    'canvasactions_definecanvas' => array(
      'file'      => 'canvasactions.inc',
      'arguments' => array('element' => NULL),
    ),
    'canvasactions_file2canvas' => array(
      'file'      => 'canvasactions.inc',
      'arguments' => array('element' => NULL),
    ),
    'canvasactions_source2canvas' => array(
      'file'      => 'canvasactions.inc',
      'arguments' => array('element' => NULL),
    ),
    'canvasactions_canvas2file' => array(
      'file'      => 'canvasactions.inc',
      'arguments' => array('element' => NULL),
    ),
    'canvasactions_roundedcorners' => array(
      'file'      => 'canvasactions.inc',
      'arguments' => array('element' => NULL),
    ),
    'canvasactions_aspect' => array(
      'file'      => 'canvasactions.inc',
      'arguments' => array('element' => NULL),
    ),
  );
}