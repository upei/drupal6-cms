<?php
// $Id: wysiwyg.module,v 1.2 2008/10/14 21:45:07 sun Exp $

/**
 * @file
 * Integrate client-side editors with Drupal.
 */

/**
 * Implementation of hook_menu().
 */
function wysiwyg_menu() {
  $items = array();
  $items['admin/settings/wysiwyg/profile'] = array(
    'title' => 'Wysiwyg',
    'page callback' => 'wysiwyg_admin',
    'description' => 'Configure client-side editor profiles.',
    'access arguments' => array('administer site configuration'),
    'file' => 'wysiwyg.admin.inc',
  );
  return $items;
}

/**
 * Implementation of hook_theme().
 */
function wysiwyg_theme() {
  return array(
    'wysiwyg_admin_button_table' => array('arguments' => array('form')),
  );
}

/**
 * Implementation of hook_help().
 */
function wysiwyg_help($path, $arg) {
  switch ($path) {
    case 'admin/settings/wysiwyg/profile':
    case 'admin/help#wysiwyg':
      $output = '<p>'. t('Profiles can be defined based on user roles. A Wysiwyg Editor profile can define which pages receive this Wysiwyg Editor capability, what buttons or themes are enabled for the editor, how the editor is displayed, and a few other editor functions. Lastly, only users with the %permission <a href="!url">user permission</a> are able to use Wysiwyg Editor.', array('%permission' => 'access wysiwyg editor', '!url' => url('admin/user/permissions'))) .'</p>';
      return $output;
  }
}

/**
 * Implementation of hook_perm().
 */
function wysiwyg_perm() {
  return array('access wysiwyg editor');
}

/**
 * Implementation of hook_elements().
 *
 * Before Drupal 7, there is no way to easily identify form fields that are
 * input format enabled. This is a workaround: We assign a form #after_build
 * processing callback that is executed on all forms after they have been
 * completely built, so that form elements already are in their effective order
 * and position.
 *
 * @see wysiwyg_process_form()
 *
 * @todo Remove #wysiwyg_style; the GUI for an editor should be solely handled
 *   via profiles, when profiles are attached to an input format. It makes no
 *   sense to display TinyMCE's simple GUI/theme for the user signature, when
 *   the input format allows users to use advanced HTML and hence, editor
 *   plugins.  Fix this here, in wysiwyg_process_element(), and lastly
 *   in wysiwyg_get_editor_config().
 */
function wysiwyg_elements() {
  $type = array();
  if (user_access('access wysiwyg editor')) {
    // @todo Derive editor theme from input format.
    $type['textarea'] = array('#wysiwyg_style' => 'advanced');
    $type['form'] = array('#after_build' => array('wysiwyg_process_form'));
  }
  return $type;
}

/**
 * Implementation of hook_form_alter().
 */
function wysiwyg_form_alter(&$form, &$form_state) {
  // Disable 'teaser' textarea.
  if (isset($form['body_field'])) {
    unset($form['body_field']['teaser_js']);
    $form['body_field']['teaser_include'] = array();
  }
}

/**
 * Process a textarea for Wysiwyg Editor.
 *
 * This way, we can recurse into the form and search for certain, hard-coded
 * elements that have been added by filter_form(). If an input format selector
 * or input format guidelines element is found, we assume that the preceding
 * element is the corresponding textarea and use it's #id for attaching
 * client-side editors.
 *
 * @see wysiwyg_elements(), filter_form()
 */
function wysiwyg_process_form(&$form) {
  // Iterate over element children; resetting array keys to access last index.
  if ($children = array_values(element_children($form))) {
    foreach ($children as $index => $item) {
      $element = &$form[$item];

      // filter_form() always uses the key 'format'. We need a type-agnostic
      // match to prevent false positives. Also, there must have been at least
      // one element on this level.
      if ($item === 'format' && $index > 0) {
        // Make sure we either match a input format selector or input format
        // guidelines (displayed if user has access to one input format only).
        if ((isset($element['#type']) && $element['#type'] == 'fieldset') || isset($element['format']['guidelines'])) {
          // The element before this element is the target form field.
          $field = &$form[$children[$index - 1]];

          // Disable #resizable to avoid resizable behavior to hi-jack the UI,
          // but load the behavior, so the 'none' editor can attach/detach it.
          $extra_class = '';
          if (!empty($field['#resizable'])) {
            // Due to our CSS class parsing, we can add arbitrary parameters
            // for each input format.
            $extra_class = ' wysiwyg-resizable-1';
            $field['#resizable'] = FALSE;
            drupal_add_js('misc/textarea.js');
          }

          // Determine the available input formats. The last child element is a
          // link to "More information about formatting options". When only one
          // input format is displayed, we also have to remove formatting
          // guidelines, stored in the child 'format'.
          $formats = element_children($element);
          array_pop($formats);
          unset($formats['format']);
          foreach ($formats as $format) {
            // Default to 'none' editor (Drupal's default behaviors).
            $editor = 'none';
            $theme = '';
            // Fetch the profile associated to this input format.
            $profile = wysiwyg_get_profile($format);
            if ($profile) {
              $editor = $profile->settings['editor'];
              // Check editor theme (and reset it if not/no longer available).
              $theme = wysiwyg_get_editor_themes($profile, $field['#wysiwyg_style']);

              // Add profile settings for this input format.
              wysiwyg_add_editor_settings($profile, $theme);
              // Add plugin settings for this input format.
              wysiwyg_add_plugin_settings($profile);

              $theme = ' wysiwyg-theme-'. $theme;
            }

            // Use a prefix/suffix for a single input format, or attach to input
            // format selector radio buttons.
            if (isset($element['format']['guidelines'])) {
              $element[$format]['#prefix'] = '<div class="wysiwyg wysiwyg-editor-'. $editor .' wysiwyg-field-'. $field['#id'] . $theme . $extra_class .'">';
              $element[$format]['#suffix'] = '</div>';
            }
            else {
              if (isset($element[$format]['#attributes']['class'])) {
                $element[$format]['#attributes']['class'] .= ' ';
              }
              else {
                $element[$format]['#attributes']['class'] = '';
              }
              $element[$format]['#attributes']['class'] .= 'wysiwyg wysiwyg-editor-'. $editor .' wysiwyg-field-'. $field['#id'] . $theme . $extra_class;
            }
          }
        }
        // If this element is 'format', do not recurse further.
        continue;
      }
      // Recurse into children.
      wysiwyg_process_form($element);
    }
  }
  return $form;
}

/**
 * Determine the profile to use for a given input format id.
 *
 * This function also performs sanity checks for the configured editor in a
 * profile to ensure that we do not load a malformed editor.
 *
 * @param $format
 *   The internal id of an input format.
 *
 * @return
 *   A wysiwyg profile.
 *
 * @see wysiwyg_load_editor(), wysiwyg_get_editor()
 *
 * @todo Replace wysiwyg_current_profile() with a input format to profile
 *   association.
 */
function wysiwyg_get_profile($format) {
  // Determine whether this input format has PHP filter enabled.
  // Temporary, until input format to profile associations are in place.
  $filters = filter_list_format($format);
  foreach ($filters as $filter) {
    if ($filter->module == 'php') {
      return FALSE;
    }
  }
  if ($profile = wysiwyg_load_profile(wysiwyg_current_profile())) {
    if (wysiwyg_load_editor($profile)) {
      return $profile;
    }
  }
  return FALSE;
}

/**
 * Load an editor library and initialize basic Wysiwyg settings.
 *
 * @param $profile
 *   A wysiwyg editor profile.
 *
 * @return
 *   TRUE if the editor has been loaded, FALSE if not.
 *
 * @see wysiwyg_get_profile()
 */
function wysiwyg_load_editor($profile) {
  static $settings_added;
  static $loaded = array();

  $name = $profile->settings['editor'];
  // Library files must be loaded only once.
  if (!isset($loaded[$name])) {
    // Load editor.
    $editor = wysiwyg_get_editor($name);
    if ($editor) {
      // Determine library files to load.
      // @todo Allow to configure the library/execMode to use.
      if (isset($profile->settings['library']) && isset($editor['libraries'][$profile->settings['library']])) {
        $library = $profile->settings['library'];
        $files = $editor['libraries'][$profile->settings['library']]['files'];
      }
      else {
        // Fallback to the first by default (external libraries can change).
        $library = key($editor['libraries']);
        $files = array_shift($editor['libraries']);
        $files = $files['files'];
      }
      foreach ($files as $file) {
        drupal_add_js($editor['library path'] . '/' . $file);
      }
      // Load JavaScript integration files for this editor.
      if (isset($editor['js files'])) {
        $files = $editor['js files'];
      }
      foreach ($files as $file) {
        drupal_add_js($editor['js path'] . '/' . $file, 'module', 'footer');
      }

      $status = wysiwyg_user_get_status($profile);
      drupal_add_js(array('wysiwyg' => array(
        'configs' => array($editor['name'] => array()),
        'showToggle' => $profile->settings['show_toggle'],
        'status' => $status,
        // If JS compression is enabled, at least TinyMCE is unable to determine
        // its own base path and exec mode since it can't find the script name.
        'editorBasePath' => base_path() . $editor['library path'],
        'execMode' => $library,
      )), 'setting');

      $loaded[$name] = TRUE;
    }
    else {
      $loaded[$name] = FALSE;
    }
  }

  // Add basic Wysiwyg settings if any editor has been added.
  if (!isset($settings_added) && $loaded[$name]) {
    drupal_add_js(array('wysiwyg' => array(
      'configs' => array(),
      'disable' => t('Disable rich-text'),
      'enable' => t('Enable rich-text'),
    )), 'setting');

    // Initialize our namespaces in the *header* to do not force editor
    // integration scripts to check and define Drupal.wysiwyg on its own.
    drupal_add_js(wysiwyg_get_path('wysiwyg.init.js'));

    // The 'none' editor is a special editor implementation, allowing us to
    // attach and detach regular Drupal behaviors just like any other editor.
    drupal_add_js(wysiwyg_get_path('editors/js/none.js'), 'module', 'footer');

    // Add wysiwyg.js to the footer to ensure it's executed after the
    // Drupal.settings array has been rendered and populated. Also, since editor
    // library initialization functions must be loaded first by the browser,
    // Drupal.wysiwygInit() must be executed AFTER editors registered
    // their callbacks, and BEFORE Drupal.behaviors are applied, this must come
    // last.
    drupal_add_js(wysiwyg_get_path('wysiwyg.js'), 'module', 'footer');

    // Add our stylesheet to stack editor buttons into one row.
    // @todo This is TinyMCE 2.x specific at the moment.
    drupal_add_css(wysiwyg_get_path('wysiwyg.css'));

    $settings_added = TRUE;
  }

  return $loaded[$name];
}

/**
 * Register a theme.
 */
function wysiwyg_add_editor_settings($profile, $theme) {
  static $themes = array();

  if (!isset($themes[$theme])) {
    $config = wysiwyg_get_editor_config($profile, $theme);
    // Convert the config values into the form expected by Wysiwyg Editor.
    // @todo Is this conversion TinyMCE specific?
    foreach ($config as $key => $value) {
      if (is_bool($value)) {
        continue;
      }
      if (is_array($value)) {
        $config[$key] = implode(',', $config[$key]);
      }
    }
    drupal_add_js(array('wysiwyg' => array('configs' => array($profile->settings['editor'] => array($theme => $config)))), 'setting');
    $themes[$theme] = TRUE;
  }
}

/**
 * Add settings for external plugins.
 * 
 * @param $profile
 *   A wysiwyg editor profile.
 */
function wysiwyg_add_plugin_settings($profile) {
  static $plugins_added = array();
  
  if (!isset($plugins_added[$profile->settings['editor']])) {
    $plugins = array();
    $editor = wysiwyg_get_editor($profile->settings['editor']);
    // Collect editor plugins provided via hook_wysiwyg_plugin().
    $info = module_invoke_all('wysiwyg_plugin', $editor['name'], $editor['installed version']);
    // Only keep enabled plugins in this profile.
    foreach ($info as $plugin => $meta) {
      if (!isset($profile->settings['buttons'][$plugin])) {
        unset($info[$plugin]);
      }
    }

    if (isset($editor['plugin settings callback']) && function_exists($editor['plugin settings callback'])) {
      $plugins = $editor['plugin settings callback']($editor, $profile, $info);
    }

    drupal_add_js(array('wysiwyg' => array('plugins' => array($profile->settings['editor'] => $plugins))), 'setting');

    $plugins_added[$profile->settings['editor']] = TRUE;
  }
}

/**
 * Grab the themes available to Wysiwyg Editor.
 *
 * Wysiwyg Editor themes control the functionality and buttons that are available to a
 * user. Themes are only looked for within the default Wysiwyg Editor theme directory.
 *
 * @param $profile
 *   A wysiwyg editor profile; passed/altered by reference.
 * @param $selected_theme
 *   An optional theme name that ought to be used.
 *
 * @return
 *   An array of theme names, or a single, checked theme name if $selected_theme
 *   was given.
 */
function wysiwyg_get_editor_themes(&$profile, $selected_theme = NULL) {
  static $themes = array();

  if (!isset($themes[$profile->settings['editor']])) {
    $editor = wysiwyg_get_editor($profile->settings['editor']);
    if (isset($editor['themes callback']) && function_exists($editor['themes callback'])) {
      $themes[$editor['name']] = $editor['themes callback']($editor, $profile);
    }
    // Fallback to 'default' otherwise.
    else {
      $themes[$editor['name']] = array('default');
    }
  }

  // Check optional $selected_theme argument, if given.
  if (isset($selected_theme)) {
    // If the passed theme name does not exist, use the first available.
    if (!isset($themes[$profile->settings['editor']][$selected_theme])) {
      $selected_theme = $profile->settings['theme'] = $themes[$profile->settings['editor']][0];
    }
  }

  return isset($selected_theme) ? $selected_theme : $themes[$profile->settings['editor']];
}

/**
 * Return plugin metadata from the plugin registry.
 *
 * @param $editor_name
 *   The internal name of an editor to return plugins for.
 *
 * @return
 *   An array for each plugin.
 */
function wysiwyg_get_plugins($editor_name) {
  $plugins = array();
  if (!empty($editor_name)) {
    $editor = wysiwyg_get_editor($editor_name);
    // Add internal editor plugins.
    if (isset($editor['plugin callback']) && function_exists($editor['plugin callback'])) {
      $plugins = $editor['plugin callback']($editor);
    }
    // Load our own plugins.
    include_once drupal_get_path('module', 'wysiwyg') .'/wysiwyg.plugins.inc';
  
    // Add editor plugins provided via hook_wysiwyg_plugin().
    $plugins = array_merge($plugins, module_invoke_all('wysiwyg_plugin', $editor['name'], $editor['installed version']));
  }
  return $plugins;
}

/**
 * Return an array of initial Wysiwyg Editor config options from the current role.
 */
function wysiwyg_get_editor_config($profile, $theme) {
  $editor = wysiwyg_get_editor($profile->settings['editor']);
  $settings = array();
  if (!empty($editor['settings callback']) && function_exists($editor['settings callback'])) {
    $settings = $editor['settings callback']($editor, $profile->settings, $theme);
  }
  return $settings;
}

/**
 * Return the name of the current user's default profile.
 */
function wysiwyg_current_profile() {
  global $user;
  static $profile_name;

  if (!isset($profile_name)) {
    $profile_name = db_result(db_query_range('SELECT p.name FROM {wysiwyg_profile} p INNER JOIN {wysiwyg_role} r ON r.name = p.name WHERE r.rid IN (%s) ORDER BY plugin_count DESC', implode(',', array_keys($user->roles)), 0, 1));
  }
  return $profile_name;
}

/**
 * Load all profiles. Just load one profile if $name is passed in.
 */
function wysiwyg_load_profile($name = '') {
  static $profiles;

  // If $name is passed from wysiwyg_current_profile(), it may be FALSE,
  // which means the user is not allowed to use a wysiwyg editor.
  if ($name === FALSE) {
    return FALSE;
  }
  if (!isset($profiles)) {
    $profiles = array();
    $roles = user_roles();
    $result = db_query('SELECT * FROM {wysiwyg_profile}');
    while ($profile = db_fetch_object($result)) {
      $profile->settings = unserialize($profile->settings);
      $result2 = db_query("SELECT rid FROM {wysiwyg_role} WHERE name = '%s'", $profile->name);
      $profile_roles = array();
      while ($role = db_fetch_object($result2)) {
        $profile_roles[$role->rid] = $roles[$role->rid];
      }
      $profile->rids = $profile_roles;

      $profiles[$profile->name] = $profile;
    }
  }

  return ($name && isset($profiles[$name]) ? $profiles[$name] : ($name ? FALSE : $profiles));
}

/**
 * Implementation of hook_user().
 */
function wysiwyg_user($type, &$edit, &$user, $category = NULL) {
  if ($type == 'form' && $category == 'account' && user_access('access wysiwyg editor')) {
    $profile = wysiwyg_user_get_profile($user);
    if (isset($profile->settings['user_choose']) && $profile->settings['user_choose']) {
      $form['wysiwyg'] = array(
        '#type' => 'fieldset',
        '#title' => t('Wysiwyg Editor settings'),
        '#weight' => 10,
        '#collapsible' => TRUE,
        '#collapsed' => TRUE,
      );
      $form['wysiwyg']['wysiwyg_status'] = array(
        '#type' => 'checkbox',
        '#title' => t('Enable editor by default'),
        '#default_value' => isset($user->wysiwyg_status) ? $user->wysiwyg_status : (isset($profile->settings['default']) ? $profile->settings['default'] : FALSE),
        '#return_value' => 1,
        '#description' => t('If enabled, rich-text editing is enabled by default in textarea fields.'),
      );
      return array('wysiwyg' => $form);
    }
  }
  if ($type == 'validate') {
    return array('wysiwyg_status' => $edit['wysiwyg_status']);
  }
}

function wysiwyg_user_get_profile($account) {
  $profile_name = db_result(db_query('SELECT s.name FROM {wysiwyg_profile} s INNER JOIN {wysiwyg_role} r ON r.name = s.name WHERE r.rid IN (%s)', implode(',', array_keys($account->roles))));
  if ($profile_name) {
    return wysiwyg_load_profile($profile_name);
  }
  else {
    return FALSE;
  }
}

function wysiwyg_user_get_status($profile) {
  global $user;
  $settings = $profile->settings;

  if ($settings['user_choose'] && isset($user->wysiwyg_status)) {
    $status = $user->wysiwyg_status;
  }
  else {
    $status = isset($settings['default']) ? $settings['default'] : FALSE;
  }

  return $status;
}

/**
 * @defgroup wysiwyg_api Wysiwyg API
 * @{
 *
 * @todo Forked from Panels; abstract into a separate API module that allows
 *   contrib modules to define supported include/plugin types.
 */

/**
 * Return library information for a given editor.
 *
 * @param $name
 *   The internal name of an editor.
 *
 * @return
 *   The library information for the editor, or FALSE if $name is unknown or not
 *   installed properly.
 */
function wysiwyg_get_editor($name) {
  $editors = wysiwyg_get_all_editors();
  return isset($editors[$name]) && $editors[$name]['installed'] ? $editors[$name] : FALSE;
}

/**
 * Compile a list holding all supported editors including installed editor version information.
 */
function wysiwyg_get_all_editors() {
  static $editors;

  if (isset($editors)) {
    return $editors;
  }

  $editors = wysiwyg_load_includes('editors', 'editor');
  foreach ($editors as $editor => $properties) {
    // Fill in required properties.
    $editors[$editor] += array(
      'title' => '',
      'vendor url' => '',
      'download url' => '',
      'editor path' => wysiwyg_get_path($properties['name']),
      'library path' => wysiwyg_get_path($properties['name']),
      'libraries' => array(),
      'version callback' => NULL,
      'themes callback' => NULL,
      'settings callback' => NULL,
      'plugin callback' => NULL,
      'plugin settings callback' => NULL,
      'versions' => array(),
      'js path' => $properties['path'] .'/js',
      'css path' => $properties['path'] .'/css',
    );
    // Check whether library is present.
    if (!($editors[$editor]['installed'] = file_exists($properties['library path']))) {
      continue;
    }
    // Detect library version.
    if (function_exists($editors[$editor]['version callback'])) {
      $editors[$editor]['installed version'] = $editors[$editor]['version callback']($properties);
    }
    if (empty($editors[$editor]['installed version'])) {
      $editors[$editor]['error'] = t('The version of %editor could not be detected.', array('%editor' => $properties['title']));
      $editors[$editor]['installed'] = FALSE;
      continue;
    }
    // Determine to which supported version the installed version maps.
    ksort($editors[$editor]['versions']);
    $version = 0;
    foreach ($editors[$editor]['versions'] as $supported_version => $version_properties) {
      if (version_compare($editors[$editor]['installed version'], $supported_version, '>=')) {
        $version = $supported_version;
      }
    }
    if (!$version) {
      $editors[$editor]['error'] = t('The installed version of %editor is not supported.', array('%editor' => $properties['title']));
      $editors[$editor]['installed'] = FALSE;
      continue;
    }
    // Apply library version specific definitions and overrides.
    $editors[$editor] = array_merge($editors[$editor], $editors[$editor]['versions'][$version]);
    unset($editors[$editor]['versions']);
    $editors[$editor]['title'] = $editors[$editor]['title'] . ' ' . $editors[$editor]['installed version'];
  }
  return $editors;
}

/**
 * Load include files for wysiwyg implemented by all modules.
 *
 * @param $type
 *   The type of includes to search for, can be 'editors'.
 * @param $hook
 *   The hook name to invoke.
 * @param $file
 *   An optional include file name without .inc extension to limit the search to.
 *
 * @see wysiwyg_get_directories(), _wysiwyg_process_include()
 */
function wysiwyg_load_includes($type = 'editors', $hook = 'editor', $file = NULL) {
  // Determine implementations.
  $directories = wysiwyg_get_directories($type);
  $directories['wysiwyg_'] = wysiwyg_get_path($type);
  $file_list = array();
  foreach ($directories as $module => $path) {
    $file_list[$module] = drupal_system_listing("$file" . '.inc$', $path, 'name', 0);
  }

  // Load implementations.
  $info = array();
  foreach (array_filter($file_list) as $module => $files) {
    foreach ($files as $file) {
      include_once './' . $file->filename;
      $result = _wysiwyg_process_include('wysiwyg', $module . $file->name, dirname($file->filename), $hook);
      if (is_array($result)) {
        $info = array_merge($info, $result);
      }
    }
  }
  return $info;
}

/**
 * Helper function to build module/file paths.
 *
 * @param $file
 *   A file or directory in a module to return.
 * @param $base_path
 *   Whether to prefix the resulting path with base_path().
 * @param $module
 *   The module name to use as prefix.
 *
 * @return
 *   The path to the specified file in a module.
 */
function wysiwyg_get_path($file = '', $base_path = FALSE, $module = 'wysiwyg') {
  $base_path = ($base_path ? base_path() : '');
  return $base_path . drupal_get_path('module', $module) . '/' . $file;
}

/**
 * Return a list of directories by modules implementing wysiwyg_include_directory().
 *
 * @param $plugintype
 *   The type of a plugin; can be 'editors'.
 *
 * @return
 *   An array containing module names suffixed with '_' and their defined
 *   directory.
 *
 * @see wysiwyg_load_includes(), _wysiwyg_process_include()
 */
function wysiwyg_get_directories($plugintype) {
  $directories = array();
  foreach (module_implements('wysiwyg_include_directory') as $module) {
    $result = module_invoke($module, 'wysiwyg_include_directory', $plugintype);
    if (isset($result) && is_string($result)) {
      $directories[$module .'_'] = drupal_get_path('module', $module) .'/'. $result;
    }
  }
  return $directories;
}

/**
 * Process a single hook implementation of a wysiwyg editor.
 *
 * @param $module
 *   The module that owns the hook.
 * @param $identifier
 *   Either the module or 'wysiwyg_' . $file->name
 * @param $hook
 *   The name of the hook being invoked.
 */
function _wysiwyg_process_include($module, $identifier, $path, $hook) {
  $function = $identifier . '_' . $hook;
  if (!function_exists($function)) {
    return NULL;
  }
  $result = $function();
  if (!isset($result) || !is_array($result)) {
    return NULL;
  }

  // Fill in defaults.
  foreach ($result as $editor => $properties) {
    $result[$editor]['module'] = $module;
    $result[$editor]['name'] = $editor;
    $result[$editor]['path'] = $path;
  }
  return $result;
}

/**
 * @} End of "defgroup wysiwyg_api".
 */

